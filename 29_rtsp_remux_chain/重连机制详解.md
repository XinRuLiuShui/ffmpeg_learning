# 重连机制详解

## 核心概念
`is_connected_` 是一个布尔标志，表示是否成功连接到RTSP流。

---

## 重连机制的完整流程

### 1️⃣ 初始化阶段
```
main()
  ↓
XDemuxTask demux_task  (is_connected_ = false 初始值)
  ↓
demux_task.Start()  (启动工作线程)
```

### 2️⃣ 工作线程 Main() 循环
```
XDemuxTask::Main()
  ↓
while (!is_exit_)
  {
    if (!demux_.is_connected())  ← 检查连接状态
    {
      Open(url_)  ← 尝试连接或重连
    }
    
    if (!demux_.Read(&pkt))  ← 读取数据
    {
      // 读取失败时更新last_time_
    }
    else
    {
      // 读取成功时更新last_time_
    }
  }
```

---

## is_connected_ 在哪里被修改？

### ✅ 修改为 true（连接成功）
**位置：** `XFormat::set_c()` 第49行

```cpp
void XFormat::set_c(AVFormatContext* c)
{
    // ... 清理旧连接 ...
    
    fmt_ctx_ = c;
    if (!fmt_ctx_)
    {
        is_connected_ = false;  ❌ 传NULL时变false
        return;
    }
    is_connected_ = true;  ✅ 连接成功时变true
    last_time_ = NowMs();  // 记录当前时间
    
    // 设置超时回调函数
    if (time_out_ms_ > 0)
    {
        AVIOInterruptCB cb = { TimeoutCallback, this };
        fmt_ctx_->interrupt_callback = cb;
    }
}
```

### ❌ 修改为 false（连接超时）
**位置1：** `XFormat::IsTimeout()` 第41行

```cpp
bool IsTimeout()
{
    // 检查是否超时：当前时间 - 最后收包时间 >= 超时时间
    if (NowMs() - last_time_ >= time_out_ms_)
    {
        last_time_ = NowMs();
        is_connected_ = false;  ❌ 数据流超时时变false
        return true;
    }
    return false;
}
```

**位置2：** `XFormat::set_c()` 第49行
```cpp
if (!fmt_ctx_)
{
    is_connected_ = false;  ❌ 传NULL时变false
    return;
}
```

---

## 超时机制的工作原理

### 关键参数
- `time_out_ms_` = 3000（3秒）
- `last_time_` = 最后一次成功收包的时间

### 超时检测流程
```
AVIOInterruptCB（FFmpeg中断回调）
  ↓
每当FFmpeg执行网络操作时都会调用 TimeoutCallback()
  ↓
TimeoutCallback() 调用 IsTimeout()
  {
    if (当前时间 - last_time_ >= 3000ms)
    {
      is_connected_ = false  ❌ 标记为断开
      return 1  (告诉FFmpeg中断操作)
    }
    else
    {
      return 0  (FFmpeg继续操作)
    }
  }
  ↓
如果返回1，FFmpeg会抛出错误 → demux_.Open() 返回nullptr
  ↓
XDemuxTask::Open() 返回false
  ↓
下次Main()循环检测到 is_connected_=false，再次尝试连接
```

---

## 完整的连接-断开-重连流程

```
第一次连接成功：
├─ Open(url) ← 连接RTSP流
├─ demux_.set_c(success_context)
│  └─ is_connected_ = true  ✅
├─ last_time_ = NowMs()
└─ 设置interrupt_callback超时回调

读取数据正常：
├─ Read(&pkt) ← 读取每个包
├─ last_time_ = NowMs()  ← 每次成功读取都更新时间戳
└─ 循环继续

数据流中断（例如VLC停止发送）：
├─ 3秒内没有新数据包
├─ interrupt_callback 调用 IsTimeout()
│  └─ NowMs() - last_time_ >= 3000
│     └─ is_connected_ = false  ❌
├─ FFmpeg中断操作，返回错误
└─ Read() 返回false，输出"- "

下次Main()循环重连：
├─ if (!is_connected_)  true
├─ Open(url) ← 重新连接
├─ demux_.set_c(new_context)
│  └─ is_connected_ = true  ✅
├─ last_time_ = NowMs()
└─ 继续读取数据
```

---

## 关键时间点追踪

| 事件 | last_time_ 更新 | is_connected_ | 位置 |
|------|-----------------|---------------|------|
| 连接成功 | ✓ | true | set_c() 第52行 |
| 读取成功 | ✓ | true | Read() 第73行 |
| 超过3秒无数据 | - | false | IsTimeout() 第41行 |
| 重新连接前 | - | false | set_c(nullptr) 第49行 |
| 重新连接成功 | ✓ | true | set_c() 第52行 |

---

## 代码流程总结

### XDemuxTask::Main()
```cpp
void Main()
{
    while (!is_exit_)
    {
        // 1. 检查连接状态（在set_c中设置）
        if (!demux_.is_connected())  // is_connected_ = false ?
        {
            Open(url_);  // 调用重连
        }
        
        // 2. 尝试读取数据
        if (!demux_.Read(&pkt))
        {
            // Read()会检查超时
            // 如果超时，IsTimeout()会设置is_connected_ = false
        }
    }
}
```

### XDemuxTask::Open()
```cpp
bool Open(std::string url, int timeout_ms)
{
    demux_.set_c(nullptr);  // is_connected_ = false
    
    demux_.set_time_out_ms(timeout_ms);  // 设置3000ms超时
    
    auto c = demux_.Open(url.c_str());  // 尝试连接
    if (!c)
        return false;  // 连接失败
    
    demux_.set_c(c);  // is_connected_ = true ✅
    return true;
}
```

---

## 你遇到的错误

**"method SETUP failed: 461 Unsupported transport"**

这不是超时问题，而是RTSP服务器不支持TCP传输。
- 注意：在你的xdemux.cpp第33行，`rtsp_transport`被注释掉了！
- 这导致FFmpeg使用默认的UDP传输，但你的VLC可能只支持TCP

### 解决方案：
取消注释并确保选择正确的传输协议：
```cpp
av_dict_set(&opts, "rtsp_transport", "tcp", 0);  // TCP
// 或
av_dict_set(&opts, "rtsp_transport", "udp", 0);  // UDP
```

